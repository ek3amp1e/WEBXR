<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>AR — Duck tightly on HIRO marker</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<style>
  body{ margin:0; background:#000; font-family:Arial,Helvetica,sans-serif; overflow:hidden; }
  canvas{ position:fixed; inset:0; width:100vw!important; height:100vh!important; display:block; }

  #ui{
    position:absolute; z-index:12; left:50%; transform:translateX(-50%); top:14px;
    background: rgba(0,0,0,0.55); padding:10px 14px; border-radius:12px; color:#fff;
    display:flex; gap:10px; align-items:center; backdrop-filter: blur(6px);
  }
  button{ background:#28a745; border:0; color:#fff; padding:8px 12px; border-radius:8px; cursor:pointer;}
  #status{ font-size:14px; }
  #hint{ position:absolute; bottom:12px; width:100%; text-align:center; color:#fff; z-index:11; font-size:14px;}
</style>
</head>
<body>

<div id="ui">
  <button id="startBtn">START AR</button>
  <div id="status">Готов — нажмите START</div>
</div>

<div id="hint">Распечатай HIRO-маркер и наведи камеру</div>

<!-- three + loader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>

<!-- AR.js (three build) -->
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/build/ar-threex.js"></script>

<script>
/*
  Этот файл:
  - приклеивает модель точно к центру маркера (bounding-box normalization)
  - подстраивает масштаб модели под "физический" размер маркера
  - показывает плоскость и оси для отладки
*/

let scene, camera, renderer;
let arSource, arContext;
let markerRoot, duck;
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');

startBtn.onclick = startAR;

function startAR(){
  startBtn.style.display = 'none';
  statusEl.innerText = 'Запуск камеры...';

  // --- Three scene & renderer
  scene = new THREE.Scene();

  camera = new THREE.Camera();
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- AR Source (высокое разрешение для стабильности)
  arSource = new THREEx.ArToolkitSource({
    sourceType: 'webcam',
    sourceWidth: 1280,
    sourceHeight: 720,
    displayWidth: window.innerWidth,
    displayHeight: window.innerHeight
  });

  arSource.init(() => {
    setTimeout(onResize, 250);
    statusEl.innerText = 'Камера включена — инициализация AR...';
  });

  window.addEventListener('resize', onResize);

  // --- AR Context
  arContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/data/camera_para.dat',
    detectionMode: 'mono'
  });

  arContext.init(() => {
    camera.projectionMatrix.copy(arContext.getProjectionMatrix());
    statusEl.innerText = 'AR initialized — ищем маркер...';
  });

  // --- Marker root
  markerRoot = new THREE.Group();
  scene.add(markerRoot);

  new THREEx.ArMarkerControls(arContext, markerRoot, {
    type: 'pattern',
    // паттерн из репозитория AR.js (используй одну из надёжных копий)
    patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/data/patt.hiro',
    // физический размер маркера в метрах (подстраивай при необходимости)
    size: 1.0,
    smooth: true
  });

  // --- Отладочная плоскость маркера (чтобы видеть центр)
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(1,1),
    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.15, side: THREE.DoubleSide })
  );
  // плоскость лежит ровно на маркере
  plane.rotation.x = -Math.PI/2;
  plane.position.set(0, 0, 0);
  markerRoot.add(plane);

  // оси: чтобы понимать ориентацию (x:red, y:green, z:blue)
  const axes = new THREE.AxesHelper(0.6);
  markerRoot.add(axes);

  // --- Light
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.8);
  dl.position.set(2,2,1);
  scene.add(dl);

  // --- Load model (duck) and normalize it to marker
  const loader = new THREE.GLTFLoader();
  const modelUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';

  loader.load(modelUrl, (gltf)=>{
    duck = gltf.scene;

    // начальный scale — небольшой, потом мы подстроим под целевой размер
    duck.scale.set(0.2,0.2,0.2);

    // Сбрасываем позицию в (0,0,0) относительно маркера — будем корректировать ниже
    duck.position.set(0,0,0);

    // НАША ВАЖНАЯ ЧАСТЬ: выравнивание по bounding box
    // чтобы модель стояла строго на плоскости маркера независимо от origin в файле
    const bbox = new THREE.Box3().setFromObject(duck);
    const size = new THREE.Vector3();
    bbox.getSize(size);
    const center = new THREE.Vector3();
    bbox.getCenter(center);

    // смещаем модель так, чтобы её центр совпал с (0, size.y/2, 0)
    // т.е. модель будет стоять на плоскости маркера.
    // Но сначала переместим модель таким образом:
    duck.position.sub(center); // теперь bbox центр уходит в 0,0,0

    // ставим модель над плоскостью: подъём = половина высоты bbox
    const halfHeight = size.y / 2;
    duck.position.y = halfHeight + 0.005; // небольшой отступ 5mm

    // Если модель кажется слишком большой, можно подогнать целевой "real" size (метров)
    // и масштабировать пропорционально:
    const TARGET_DIAGONAL_METERS = 0.4; // желаемая диагональ модели ~0.4м (подстроить)
    const currentDiagonal = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
    if(currentDiagonal > 0){
      const scaleFactor = TARGET_DIAGONAL_METERS / currentDiagonal;
      duck.scale.multiplyScalar(scaleFactor);
    }

    // Скрываем по умолчанию — показываем только когда маркер виден
    duck.visible = false;

    // Добавляем в markerRoot — модель теперь в координатах маркера
    markerRoot.add(duck);

    statusEl.innerText = 'Модель загружена — ищем маркер...';
  },
  undefined,
  err => { console.error('Model load error', err); statusEl.innerText = 'Ошибка загрузки модели';});

  // start render loop
  requestAnimationFrame(tick);
}

function onResize(){
  if(!arSource) return;
  arSource.onResize();             // обновляем размер source
  arSource.copySizeTo(renderer.domElement); // копируем в рендерер

  if(arContext && arContext.arController){
    arSource.copySizeTo(arContext.arController.canvas); // и в arController
  }
}

let lastShow = 0;
const MIN_VISIBLE_FRAMES = 4;
let visibleFrames = 0;

function tick(){
  requestAnimationFrame(tick);

  if(arSource && arSource.ready){
    arContext.update(arSource.domElement);
  }

  // если маркер виден — показываем модель (после нескольких кадров подтверждения)
  if(markerRoot){
    if(markerRoot.visible){
      visibleFrames++;
      if(visibleFrames >= MIN_VISIBLE_FRAMES){
        if(duck){
          duck.visible = true;
          // лёгкая анимация только если видим
          duck.rotation.y += 0.01;
        }
        lastShow = performance.now();
      }
      document.getElementById('status').innerText = 'Маркер найден ✅';
    } else {
      // если кратковременно потерялся — даём small grace (300ms)
      if(performance.now() - lastShow < 300){
        // ничего не делаем — удерживаем модель
      } else {
        visibleFrames = 0;
        if(duck) duck.visible = false;
        document.getElementById('status').innerText = 'Ищем маркер...';
      }
    }
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
