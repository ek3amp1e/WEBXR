<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Duck on Marker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #startButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            z-index: 10;
            cursor: pointer;
        }
        #info {
            position: absolute;
            bottom: 20px;
            text-align: center;
            width: 100%;
            color: white;
            font-size: 18px;
            z-index: 10;
        }
    </style>
</head>
<body>

<button id="startButton">START AR</button>
<div id="info">Наведите камеру на маркер</div>

<!-- Three -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>

<!-- AR.js -->
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/build/ar-threex.js"></script>

<script>
let scene, camera, renderer;
let arToolkitSource, arToolkitContext;
let markerRoot, duck;

// Цвета для смены
const colors = [0xffffff, 0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
let colorIndex = 0;

// Raycaster для определения клика по утке
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// ==================
// Запуск камеры
// ==================
document.getElementById("startButton").addEventListener("click", startAR);

function startAR() {
    document.getElementById("startButton").style.display = "none";

    scene = new THREE.Scene();

    camera = new THREE.Camera();
    scene.add(camera);

    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Камера
    arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
    arToolkitSource.init(() => { onResize(); });
    window.addEventListener('resize', onResize);

    // Контекст AR
    arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/data/data/camera_para.dat',
        detectionMode: 'mono'
    });
    arToolkitContext.init(() => camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix()));

    // ==================
    // Маркер
    // ==================
    markerRoot = new THREE.Group();
    scene.add(markerRoot);

    new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
        type: 'pattern',
        patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/data/data/patt.hiro'
    });

    // ==================
    // Свет
    // ==================
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1, 1, 1);
    scene.add(dir);

    // ==================
    // Загрузка утки
    // ==================
    new THREE.GLTFLoader().load(
        'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb',
        gltf => {
            duck = gltf.scene;
            duck.scale.set(0.5, 0.5, 0.5);
            duck.position.y = 0.2;

            markerRoot.add(duck);
        }
    );

    // Слушаем клики/тачи
    window.addEventListener('pointerdown', onDuckClick);

    animate();
}

function onResize() {
    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);
    if (arToolkitContext.arController) {
        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
}

// ==================
// Обработка клика по утке
// ==================
function onDuckClick(event) {
    if (!duck) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(duck, true);

    if (intersects.length > 0) {
        colorIndex = (colorIndex + 1) % colors.length;

        duck.traverse(obj => {
            if (obj.isMesh) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(mat => { if(mat.color) mat.color.setHex(colors[colorIndex]); });
                } else {
                    if(obj.material.color) obj.material.color.setHex(colors[colorIndex]);
                }
            }
        });
    }
}

// ==================
// Цикл рендера
// ==================
function animate() {
    requestAnimationFrame(animate);

    if (!arToolkitSource.ready) return;

    arToolkitContext.update(arToolkitSource.domElement);

    // Вращаем утку на маркере
    if (duck) duck.rotation.y += 0.01;

    renderer.render(scene, camera);
}
</script>

</body>
</html>
