<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Кирюха молодец</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
      z-index: 99;
      pointer-events: none;
    }
  </style>

  <script>
    // ================================
    // GESTURE DETECTOR (вшить безопасные детали)
    // ================================
    AFRAME.registerComponent("gesture-detector", {
      schema: { element: { default: "" } },
      init: function () {
        this.targetElement = this.data.element && document.querySelector(this.data.element);
        if (!this.targetElement) { this.targetElement = this.el; }
        this.internalState = { previousState: null };
        this.emitGestureEvent = this.emitGestureEvent.bind(this);

        // Используем passive: false чтобы иметь возможность preventDefault, если потребуется
        this.targetElement.addEventListener("touchstart", this.emitGestureEvent, { passive: true });
        this.targetElement.addEventListener("touchend", this.emitGestureEvent, { passive: true });
        this.targetElement.addEventListener("touchmove", this.emitGestureEvent, { passive: true });
      },
      remove: function () {
        this.targetElement.removeEventListener("touchstart", this.emitGestureEvent);
        this.targetElement.removeEventListener("touchend", this.emitGestureEvent);
        this.targetElement.removeEventListener("touchmove", this.emitGestureEvent);
      },
      emitGestureEvent: function (event) {
        const currentState = this.getTouchState(event);
        const previousState = this.internalState.previousState;
        const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
        const gestureEnded = previousState && !gestureContinues;
        const gestureStarted = currentState && !gestureContinues;

        if (gestureEnded) {
          const eventName = this.getEventPrefix(previousState.touchCount) + "fingerend";
          this.el.emit(eventName, previousState);
          this.internalState.previousState = null;
        }
        if (gestureStarted) {
          currentState.startTime = performance.now();
          currentState.startPosition = currentState.position;
          currentState.startSpread = currentState.spread;
          const eventName = this.getEventPrefix(currentState.touchCount) + "fingerstart";
          this.el.emit(eventName, currentState);
          this.internalState.previousState = currentState;
        }
        if (gestureContinues) {
          // Отправляем подробный detail: текущий spread и прошлый spread + spreadChange
          const detail = {
            positionChange: {
              x: currentState.position.x - previousState.position.x,
              y: currentState.position.y - previousState.position.y
            },
            spreadChange: currentState.spread - previousState.spread,
            startSpread: previousState.startSpread !== undefined ? previousState.startSpread : currentState.startSpread,
            // добавим текущий и предыдущий spread для более безопасных вычислений в handler'е
            currentSpread: currentState.spread,
            previousSpread: previousState.spread,
            position: currentState.position
          };
          const eventName = this.getEventPrefix(currentState.touchCount) + "fingermove";
          this.el.emit(eventName, detail);
          // обновим previousState (копируем, чтобы startSpread сохранилось)
          this.internalState.previousState = {
            ...currentState,
            startSpread: this.internalState.previousState.startSpread
          };
        }
      },
      getTouchState: function (event) {
        if (!event.touches || event.touches.length === 0) { return null; }
        const touches = Array.from(event.touches);
        const touchMean = touches.reduce((acc, touch) => {
          return { x: acc.x + touch.clientX, y: acc.y + touch.clientY };
        }, { x: 0, y: 0 });
        touchMean.x /= touches.length;
        touchMean.y /= touches.length;

        const spread = touches.reduce((acc, touch) => {
          return acc + Math.sqrt(
            Math.pow(touch.clientX - touchMean.x, 2) +
            Math.pow(touch.clientY - touchMean.y, 2)
          );
        }, 0) / touches.length;

        return {
          touchCount: touches.length,
          position: touchMean,
          spread
        };
      },
      getEventPrefix: function (touchCount) {
        const names = ["one", "two", "three", "many"];
        return names[Math.min(Math.max(touchCount,1), 4) - 1];
      }
    });


    // ================================
    // GESTURE HANDLER (Robust scale & rotation)
    // ================================
    AFRAME.registerComponent("gesture-handler", {
      schema: {
        enabled: { default: true },
        rotationFactor: { default: 5 },
        minScale: { default: 0.01 },
        maxScale: { default: 8 },
        pinchSensitivity: { default: 1.0 } // можно уменьшить если слишком чувствительно
      },
      init: function () {
        this.handleScale = this.handleScale.bind(this);
        this.handleRotation = this.handleRotation.bind(this);
        this.isVisible = false;

        // Берём начальный scale (защищаемся если атрибут не задан)
        const initialScaleAttr = this.el.getAttribute('scale') || { x: 1, y: 1, z: 1 };
        this.initialScale = {
          x: parseFloat(initialScaleAttr.x) || 1,
          y: parseFloat(initialScaleAttr.y) || 1,
          z: parseFloat(initialScaleAttr.z) || 1
        };
        this.scaleFactor = 1;

        // Ищем ближайший родитель с mindar-image-target (на случай другой вложенности)
        const targetEl = this.el.closest('[mindar-image-target]');
        if (targetEl) {
          targetEl.addEventListener("targetFound", () => { this.isVisible = true; });
          targetEl.addEventListener("targetLost", () => { this.isVisible = false; });
        } else {
          // fallback: слушаем сцену (если таргет не найден)
          console.warn('gesture-handler: mindar-image-target not found as ancestor; targetFound/targetLost will not be tracked.');
        }
      },
      update: function () {
        if (!this.el.sceneEl) return;
        if (this.data.enabled) {
          this.el.sceneEl.addEventListener("twofingermove", this.handleScale);
          this.el.sceneEl.addEventListener("onefingermove", this.handleRotation);
        } else {
          this.el.sceneEl.removeEventListener("twofingermove", this.handleScale);
          this.el.sceneEl.removeEventListener("onefingermove", this.handleRotation);
        }
      },
      remove: function () {
        if (this.el.sceneEl) {
          this.el.sceneEl.removeEventListener("twofingermove", this.handleScale);
          this.el.sceneEl.removeEventListener("onefingermove", this.handleRotation);
        }
      },
      handleRotation: function (event) {
        try {
          if (!this.isVisible) return;
          if (!event || !event.detail || !event.detail.positionChange) return;
          const dx = event.detail.positionChange.x;
          if (!isFinite(dx)) return;
          // Мягкое вращение, можно регулировать rotationFactor
          this.el.object3D.rotation.y += dx * this.data.rotationFactor * 0.005;
        } catch (err) {
          console.error('rotation error', err);
        }
      },
      handleScale: function (event) {
        try {
          if (!this.isVisible) return;
          if (!event || !event.detail) return;

          const d = event.detail;

          // Попытка 1: рассчитать отношение spread (более устойчиво)
          let pinchRatio = NaN;
          if (isFinite(d.currentSpread) && isFinite(d.previousSpread) && d.previousSpread > 1e-6) {
            pinchRatio = (d.currentSpread / d.previousSpread);
          } else if (isFinite(d.startSpread) && Math.abs(d.startSpread) > 1e-6) {
            // fallback: отношение текущего к стартовому, если предыдущий недоступен
            const currentSpread = d.startSpread + (isFinite(d.spreadChange) ? d.spreadChange : 0);
            if (isFinite(currentSpread) && currentSpread > 1e-6) {
              pinchRatio = currentSpread / d.startSpread;
            }
          }

          // Второй fallback: использовать вертикальное смещение двух пальцев
          if (!isFinite(pinchRatio)) {
            if (d.positionChange && isFinite(d.positionChange.y)) {
              // вертикальный сдвиг уменьшает/увеличивает
              pinchRatio = 1 + ( - d.positionChange.y * 0.01 * this.data.pinchSensitivity );
            } else {
              pinchRatio = 1;
            }
          }

          // Ограничим скачки в одном событии (чтобы не получить огромные значения)
          const MIN_STEP = 0.5; // если требуется, можно уменьшить
          const MAX_STEP = 1.5;
          if (!isFinite(pinchRatio) || pinchRatio <= 0) return; // защита от NaN/0/отриц
          pinchRatio = Math.max(MIN_STEP, Math.min(MAX_STEP, pinchRatio));

          // Вычисляем новый scaleFactor и защищаем от NaN / бесконечности
          let newScaleFactor = this.scaleFactor * pinchRatio;
          if (!isFinite(newScaleFactor)) return;

          newScaleFactor = Math.max(this.data.minScale, Math.min(this.data.maxScale, newScaleFactor));

          // Применяем масштаб к объекту, опираясь на исходный scale
          this.scaleFactor = newScaleFactor;
          const sx = this.scaleFactor * this.initialScale.x;
          const sy = this.scaleFactor * this.initialScale.y;
          const sz = this.scaleFactor * this.initialScale.z;

          // Дополнительная защита: числа должны быть конечными
          if ([sx, sy, sz].some(v => !isFinite(v) || v <= 0)) {
            console.warn('gesture-handler: invalid scale computed, ignoring.');
            return;
          }

          this.el.object3D.scale.set(sx, sy, sz);
          // Убедимся, что объект видим (иногда при ошибок scale он мог стать невидим)
          this.el.object3D.visible = true;

        } catch (err) {
          console.error('scale error', err);
        }
      }
    });


    // ================================
    // AR INTERACTIVITY: звук и targetFound
    // ================================
    AFRAME.registerComponent("ar-interactivity-handler", {
      init: function () {
        const sceneEl = this.el.sceneEl;

        // Найдём таргет (безопасно)
        const targetEl = () => sceneEl ? sceneEl.querySelector('[mindar-image-target]') : null;

        // Покажем оверлей с кнопкой, чтобы разблокировать звук на iOS
        const buttonHTML = `
          <div id="soundOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; flex-direction: column;">
            <p style="color: white; margin-bottom: 20px; font-family: sans-serif;">Наведите камеру на маркер и нажмите кнопку</p>
            <button id="playButton" style="padding: 15px 30px; font-size: 18px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">Запустить AR-опыт со звуком</button>
          </div>
        `;
        document.body.insertAdjacentHTML('beforeend', buttonHTML);
        const playButton = document.querySelector('#playButton');
        const soundOverlay = document.querySelector('#soundOverlay');

        // Используем чистый HTMLAudioElement (надежнее на мобильных)
        const audioEl = document.querySelector('#audioFile'); // <audio> в assets
        let soundReady = false;

        // Разблокировка звука по нажатию
        playButton.addEventListener('click', async () => {
          soundOverlay.style.display = 'none';
          soundReady = true;
          // Попробуем прогреть аудио (для iOS)
          if (audioEl) {
            try {
              // small play/pause to unlock
              await audioEl.play();
              audioEl.pause();
              audioEl.currentTime = 0;
            } catch (err) {
              // ignore promise rejection
              console.warn('audio unlock attempt failed', err);
            }
          }
        }, { once: true });

        // Добавим подписку на targetFound/targetLost (проверка в цикле, т.к. scene может инициализироваться позже)
        const attachTargetListeners = () => {
          const t = targetEl();
          if (!t) return false;

          t.addEventListener('targetFound', () => {
            try {
              if (soundReady && audioEl) {
                // В случае частого триггера - гарантируем, что звук начнётся с начала
                audioEl.pause();
                audioEl.currentTime = 0;
                const p = audioEl.play();
                if (p && p.catch) p.catch(e => { /* ignore */ });
              } else {
                // показать подсказку если ещё не разблокировали звук
                if (soundOverlay) soundOverlay.style.display = 'flex';
              }
            } catch (err) {
              console.error('targetFound handler error', err);
            }
          });

          t.addEventListener('targetLost', () => {
            try {
              if (audioEl && !audioEl.paused) {
                audioEl.pause();
                // reset to start optionally
                audioEl.currentTime = 0;
              }
            } catch (err) {
              console.error('targetLost handler error', err);
            }
          });

          return true;
        };

        // Попробуем прикрепиться сразу, иначе ждём и проверяем несколько раз
        if (!attachTargetListeners()) {
          // если таргет ещё не добавлен, проверим периодически в течение краткого времени
          let tries = 0;
          const intervalId = setInterval(() => {
            tries++;
            if (attachTargetListeners() || tries > 30) {
              clearInterval(intervalId);
            }
          }, 300);
        }
      }
    });
  </script>
</head>

<body>
  <div id="overlay">
    1 палец: Вращение<br>
    2 пальца: Масштабирование
  </div>

  <a-scene
    mindar-image="imageTargetSrc: https://raw.githubusercontent.com/XABANSKIY/43554534/main/targets.mind;"
    color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false"
    gesture-detector
    ar-interactivity-handler>

    <a-assets>
      <a-asset-item id="robotModel" src="https://raw.githubusercontent.com/XABANSKIY/43554534/main/studio_c_chuck_real_textures.glb"></a-asset-item>
      <!-- Используем обычный <audio> для управления воспроизведением из JS -->
      <audio id="audioFile" src="https://raw.githubusercontent.com/XABANSKIY/43554534/main/received-mail-notification.mp3" preload="auto"></audio>
    </a-assets>

    <!-- Удалил <a-sound>, управляю audio через JS напрямую, это надежнее на мобильных -->
    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <a-entity mindar-image-target="targetIndex: 0">
      <a-gltf-model
        id="ar-model"
        src="#robotModel"
        position="0 -0.25 0"
        scale="0.05 0.05 0.05"
        rotation="0 0 0"
        gesture-handler>
      </a-gltf-model>
    </a-entity>
  </a-scene>
</body>
</html>
